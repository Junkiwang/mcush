; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\usb_istr.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\usb_istr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -I..\..\..\..\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\..\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL ..\src\usb_istr.c]
                          THUMB

                          AREA ||i.USB_Istr||, CODE, READONLY, ALIGN=2

                  USB_Istr PROC
;;;76     *******************************************************************************/
;;;77     void USB_Istr(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;78     {
;;;79         uint32_t i=0;
;;;80      __IO uint32_t EP[8];
;;;81       
;;;82       wIstr = _GetISTR();
000004  4e4a              LDR      r6,|L1.304|
000006  b088              SUB      sp,sp,#0x20           ;78
000008  2400              MOVS     r4,#0                 ;79
00000a  6830              LDR      r0,[r6,#0]
00000c  4d49              LDR      r5,|L1.308|
00000e  8068              STRH     r0,[r5,#2]
;;;83     #if (IMR_MSK & ISTR_CTR)
;;;84       if (wIstr & ISTR_CTR & wInterrupt_Mask)
000010  8868              LDRH     r0,[r5,#2]  ; wIstr
000012  4f49              LDR      r7,|L1.312|
000014  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
000016  4008              ANDS     r0,r0,r1
000018  0400              LSLS     r0,r0,#16
00001a  d501              BPL      |L1.32|
;;;85       {
;;;86         /* servicing of the endpoint correct transfer interrupt */
;;;87         /* clear of the CTR flag into the sub */
;;;88         CTR_LP();
00001c  f7fffffe          BL       CTR_LP
                  |L1.32|
;;;89     #ifdef CTR_CALLBACK
;;;90         CTR_Callback();
;;;91     #endif
;;;92       }
;;;93     #endif  
;;;94       /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;95     #if (IMR_MSK & ISTR_RESET)
;;;96       if (wIstr & ISTR_RESET & wInterrupt_Mask)
000020  8868              LDRH     r0,[r5,#2]  ; wIstr
000022  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
;;;97       {
;;;98         _SetISTR((uint16_t)CLR_RESET);
000024  f64f38ff          MOV      r8,#0xfbff
000028  4008              ANDS     r0,r0,r1              ;96
00002a  0540              LSLS     r0,r0,#21             ;96
00002c  d504              BPL      |L1.56|
00002e  f8c68000          STR      r8,[r6,#0]
;;;99         Device_Property.Reset();
000032  4842              LDR      r0,|L1.316|
000034  6840              LDR      r0,[r0,#4]  ; Device_Property
000036  4780              BLX      r0
                  |L1.56|
;;;100    #ifdef RESET_CALLBACK
;;;101        RESET_Callback();
;;;102    #endif
;;;103      }
;;;104    #endif
;;;105      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;106    #if (IMR_MSK & ISTR_DOVR)
;;;107      if (wIstr & ISTR_DOVR & wInterrupt_Mask)
;;;108      {
;;;109        _SetISTR((uint16_t)CLR_DOVR);
;;;110    #ifdef DOVR_CALLBACK
;;;111        DOVR_Callback();
;;;112    #endif
;;;113      }
;;;114    #endif
;;;115      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;116    #if (IMR_MSK & ISTR_ERR)
;;;117      if (wIstr & ISTR_ERR & wInterrupt_Mask)
000038  8869              LDRH     r1,[r5,#2]  ; wIstr
00003a  8838              LDRH     r0,[r7,#0]  ; wInterrupt_Mask
00003c  4001              ANDS     r1,r1,r0
00003e  0489              LSLS     r1,r1,#18
000040  d502              BPL      |L1.72|
;;;118      {
;;;119        _SetISTR((uint16_t)CLR_ERR);
000042  f64d71ff          MOV      r1,#0xdfff
000046  6031              STR      r1,[r6,#0]
                  |L1.72|
;;;120    #ifdef ERR_CALLBACK
;;;121        ERR_Callback();
;;;122    #endif
;;;123      }
;;;124    #endif
;;;125      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;126    #if (IMR_MSK & ISTR_WKUP)
;;;127      if (wIstr & ISTR_WKUP & wInterrupt_Mask)
000048  8869              LDRH     r1,[r5,#2]  ; wIstr
00004a  4001              ANDS     r1,r1,r0
00004c  04c8              LSLS     r0,r1,#19
00004e  d505              BPL      |L1.92|
;;;128      {
;;;129        _SetISTR((uint16_t)CLR_WKUP);
000050  f64e70ff          MOV      r0,#0xefff
000054  6030              STR      r0,[r6,#0]
;;;130        Resume(RESUME_EXTERNAL);
000056  2000              MOVS     r0,#0
000058  f7fffffe          BL       Resume
                  |L1.92|
;;;131    #ifdef WKUP_CALLBACK
;;;132        WKUP_Callback();
;;;133    #endif
;;;134      }
;;;135    #endif
;;;136      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;137    #if (IMR_MSK & ISTR_SUSP)
;;;138      if (wIstr & ISTR_SUSP & wInterrupt_Mask)
00005c  8868              LDRH     r0,[r5,#2]  ; wIstr
00005e  8839              LDRH     r1,[r7,#0]  ; wInterrupt_Mask
000060  4008              ANDS     r0,r0,r1
000062  0500              LSLS     r0,r0,#20
000064  d50b              BPL      |L1.126|
;;;139      {
;;;140    
;;;141        /* check if SUSPEND is possible */
;;;142        if (fSuspendEnabled)
000066  4836              LDR      r0,|L1.320|
000068  7800              LDRB     r0,[r0,#0]  ; fSuspendEnabled
00006a  b110              CBZ      r0,|L1.114|
;;;143        {
;;;144          Suspend();
00006c  f7fffffe          BL       Suspend
000070  e002              B        |L1.120|
                  |L1.114|
;;;145        }
;;;146        else
;;;147        {
;;;148          /* if not possible then resume after xx ms */
;;;149          Resume(RESUME_LATER);
000072  2002              MOVS     r0,#2
000074  f7fffffe          BL       Resume
                  |L1.120|
;;;150        }
;;;151        /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
;;;152        _SetISTR((uint16_t)CLR_SUSP);
000078  f24f70ff          MOV      r0,#0xf7ff
00007c  6030              STR      r0,[r6,#0]
                  |L1.126|
;;;153    #ifdef SUSP_CALLBACK
;;;154        SUSP_Callback();
;;;155    #endif
;;;156      }
;;;157    #endif
;;;158      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;159    #if (IMR_MSK & ISTR_SOF)
;;;160      if (wIstr & ISTR_SOF & wInterrupt_Mask)
00007e  8869              LDRH     r1,[r5,#2]  ; wIstr
000080  8838              LDRH     r0,[r7,#0]  ; wInterrupt_Mask
000082  4001              ANDS     r1,r1,r0
000084  0589              LSLS     r1,r1,#22
000086  d505              BPL      |L1.148|
;;;161      {
;;;162        _SetISTR((uint16_t)CLR_SOF);
000088  f64f51ff          MOV      r1,#0xfdff
00008c  6031              STR      r1,[r6,#0]
;;;163        bIntPackSOF++;
00008e  7829              LDRB     r1,[r5,#0]  ; bIntPackSOF
000090  1c49              ADDS     r1,r1,#1
000092  7029              STRB     r1,[r5,#0]
                  |L1.148|
;;;164    
;;;165    #ifdef SOF_CALLBACK
;;;166        SOF_Callback();
;;;167    #endif
;;;168      }
;;;169    #endif
;;;170      /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
;;;171    #if (IMR_MSK & ISTR_ESOF)
;;;172      if (wIstr & ISTR_ESOF & wInterrupt_Mask)
000094  8869              LDRH     r1,[r5,#2]  ; wIstr
000096  4001              ANDS     r1,r1,r0
000098  05c8              LSLS     r0,r1,#23
00009a  d545              BPL      |L1.296|
;;;173      {
;;;174        /* clear ESOF flag in ISTR */
;;;175        _SetISTR((uint16_t)CLR_ESOF);
00009c  f64f60ff          MOV      r0,#0xfeff
0000a0  6030              STR      r0,[r6,#0]
;;;176        
;;;177        if ((_GetFNR()&FNR_RXDP)!=0)
0000a2  4823              LDR      r0,|L1.304|
0000a4  1d00              ADDS     r0,r0,#4
0000a6  6800              LDR      r0,[r0,#0]
0000a8  f04f0100          MOV      r1,#0
0000ac  0400              LSLS     r0,r0,#16
0000ae  d537              BPL      |L1.288|
;;;178        {
;;;179          /* increment ESOF counter */
;;;180          esof_counter ++;
0000b0  6868              LDR      r0,[r5,#4]  ; esof_counter
0000b2  1c40              ADDS     r0,r0,#1
0000b4  6068              STR      r0,[r5,#4]  ; esof_counter
;;;181          
;;;182          /* test if we enter in ESOF more than 3 times with FSUSP =0 and RXDP =1=>> possible missing SUSP flag*/
;;;183          if ((esof_counter >3)&&((_GetCNTR()&CNTR_FSUSP)==0))
0000b6  6868              LDR      r0,[r5,#4]  ; esof_counter
0000b8  2803              CMP      r0,#3
0000ba  d932              BLS      |L1.290|
0000bc  481c              LDR      r0,|L1.304|
0000be  1f00              SUBS     r0,r0,#4
0000c0  6802              LDR      r2,[r0,#0]
0000c2  0712              LSLS     r2,r2,#28
0000c4  d42d              BMI      |L1.290|
;;;184          {           
;;;185            /* this a sequence to apply a force RESET*/
;;;186          
;;;187            /*Store CNTR value */
;;;188            wCNTR = _GetCNTR(); 
0000c6  6802              LDR      r2,[r0,#0]
0000c8  b292              UXTH     r2,r2
0000ca  60aa              STR      r2,[r5,#8]  ; wCNTR
;;;189          
;;;190            /*Store endpoints registers status */
;;;191            for (i=0;i<8;i++) EP[i] = _GetENDPOINT(i);
0000cc  4a1d              LDR      r2,|L1.324|
0000ce  466b              MOV      r3,sp
                  |L1.208|
0000d0  eb020784          ADD      r7,r2,r4,LSL #2
0000d4  f8d77c00          LDR      r7,[r7,#0xc00]
0000d8  b2bf              UXTH     r7,r7
0000da  f8437024          STR      r7,[r3,r4,LSL #2]
0000de  1c64              ADDS     r4,r4,#1
0000e0  2c08              CMP      r4,#8
0000e2  d3f5              BCC      |L1.208|
;;;192          
;;;193            /*apply FRES */
;;;194            wCNTR|=CNTR_FRES;
0000e4  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000e6  f0440401          ORR      r4,r4,#1
0000ea  60ac              STR      r4,[r5,#8]  ; wCNTR
;;;195            _SetCNTR(wCNTR);
0000ec  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000ee  b2a4              UXTH     r4,r4
0000f0  6004              STR      r4,[r0,#0]
;;;196     
;;;197            /*clear FRES*/
;;;198            wCNTR&=~CNTR_FRES;
0000f2  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000f4  f0240401          BIC      r4,r4,#1
0000f8  60ac              STR      r4,[r5,#8]  ; wCNTR
;;;199            _SetCNTR(wCNTR);
0000fa  68ac              LDR      r4,[r5,#8]  ; wCNTR
0000fc  b2a4              UXTH     r4,r4
0000fe  6004              STR      r4,[r0,#0]
                  |L1.256|
;;;200          
;;;201            /*poll for RESET flag in ISTR*/
;;;202            while((_GetISTR()&ISTR_RESET) == 0);
000100  6830              LDR      r0,[r6,#0]
000102  0540              LSLS     r0,r0,#21
000104  d5fc              BPL      |L1.256|
;;;203      
;;;204            /* clear RESET flag in ISTR */
;;;205            _SetISTR((uint16_t)CLR_RESET);
000106  f8c68000          STR      r8,[r6,#0]
;;;206       
;;;207           /*restore Enpoints*/
;;;208            for (i=0;i<8;i++)
00010a  2000              MOVS     r0,#0
                  |L1.268|
;;;209            _SetENDPOINT(i, EP[i]);
00010c  f8534020          LDR      r4,[r3,r0,LSL #2]
000110  eb020680          ADD      r6,r2,r0,LSL #2
000114  b2a4              UXTH     r4,r4
000116  f8c64c00          STR      r4,[r6,#0xc00]
00011a  1c40              ADDS     r0,r0,#1
00011c  2808              CMP      r0,#8                 ;208
00011e  d3f5              BCC      |L1.268|
                  |L1.288|
;;;210          
;;;211            esof_counter = 0;
000120  6069              STR      r1,[r5,#4]  ; esof_counter
                  |L1.290|
;;;212          }
;;;213        }
;;;214        else
;;;215        {
;;;216            esof_counter = 0;
;;;217        }
;;;218        
;;;219        /* resume handling timing is made with ESOFs */
;;;220        Resume(RESUME_ESOF); /* request without change of the machine state */
000122  2007              MOVS     r0,#7
000124  f7fffffe          BL       Resume
                  |L1.296|
;;;221    #ifdef ESOF_CALLBACK
;;;222        ESOF_Callback();
;;;223    #endif
;;;224        
;;;225      }
;;;226    #endif
;;;227    } /* USB_Istr */
000128  b008              ADD      sp,sp,#0x20
00012a  e8bd81f0          POP      {r4-r8,pc}
;;;228    
                          ENDP

00012e  0000              DCW      0x0000
                  |L1.304|
                          DCD      0x40005c44
                  |L1.308|
                          DCD      ||.data||
                  |L1.312|
                          DCD      wInterrupt_Mask
                  |L1.316|
                          DCD      Device_Property
                  |L1.320|
                          DCD      fSuspendEnabled
                  |L1.324|
                          DCD      0x40005000

                          AREA ||.data||, DATA, ALIGN=2

                  bIntPackSOF
000000  0000              DCB      0x00,0x00
                  wIstr
000002  0000              DCB      0x00,0x00
                  esof_counter
                          DCD      0x00000000
                  wCNTR
                          DCD      0x00000000

                          AREA ||area_number.5||, DATA, ALIGN=2

                          EXPORTAS ||area_number.5||, ||.data||
                  pEpInt_IN
                          DCD      EP1_IN_Callback
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

                          AREA ||area_number.6||, DATA, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.data||
                  pEpInt_OUT
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process

;*** Start embedded assembler ***

#line 1 "..\\src\\usb_istr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REV16|
#line 388 "..\\..\\..\\..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_usb_istr_c_e9471872____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____REVSH|
#line 402
|__asm___10_usb_istr_c_e9471872____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_istr_c_e9471872____RRX|
#line 587
|__asm___10_usb_istr_c_e9471872____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
