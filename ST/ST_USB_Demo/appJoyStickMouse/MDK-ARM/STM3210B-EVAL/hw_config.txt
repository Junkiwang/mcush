; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\stm3210b-eval\hw_config.o --asm_dir=.\STM3210B-EVAL\ --list_dir=.\STM3210B-EVAL\ --depend=.\stm3210b-eval\hw_config.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\inc -I..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\..\Utilities\STM32_EVAL -I..\..\..\Utilities\STM32_EVAL\Common -I..\..\..\Utilities\STM32_EVAL\STM3210B_EVAL -I..\..\..\..\CMSIS\Device\ST\STM32F10x\Include -I..\..\..\..\CMSIS\Include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DUSE_STM3210B_EVAL ..\src\hw_config.c]
                          THUMB

                          AREA ||i.Enter_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Enter_LowPowerMode PROC
;;;256    *******************************************************************************/
;;;257    void Enter_LowPowerMode(void)
000000  4906              LDR      r1,|L1.28|
;;;258    {
000002  b510              PUSH     {r4,lr}
;;;259      /* Set the device state to suspend */
;;;260      bDeviceState = SUSPENDED;
000004  2003              MOVS     r0,#3
000006  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;261    
;;;262      /* Clear EXTI Line18 pending bit */
;;;263      EXTI_ClearITPendingBit(KEY_BUTTON_EXTI_LINE);
000008  f44f7000          MOV      r0,#0x200
00000c  f7fffffe          BL       EXTI_ClearITPendingBit
;;;264    
;;;265      /* Request to enter STOP mode with regulator in low power mode */
;;;266      PWR_EnterSTOPMode(PWR_Regulator_LowPower, PWR_STOPEntry_WFI);
000010  2101              MOVS     r1,#1
000012  e8bd4010          POP      {r4,lr}
000016  4608              MOV      r0,r1
000018  f7ffbffe          B.W      PWR_EnterSTOPMode
;;;267    }
;;;268    
                          ENDP

                  |L1.28|
                          DCD      bDeviceState

                          AREA ||i.GPIO_AINConfig||, CODE, READONLY, ALIGN=2

                  GPIO_AINConfig PROC
;;;207    #ifndef STM32F37X 
;;;208    void GPIO_AINConfig(void)
000000  b508              PUSH     {r3,lr}
;;;209    {
;;;210      GPIO_InitTypeDef GPIO_InitStructure;
;;;211    
;;;212    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)|| defined(STM32F30X)
;;;213      /* Enable all GPIOs Clock*/
;;;214      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_ALLGPIO, ENABLE);  
;;;215    #else 
;;;216      /* Enable all GPIOs Clock*/
;;;217      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ALLGPIO, ENABLE);
000002  2101              MOVS     r1,#1
000004  207c              MOVS     r0,#0x7c
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;218    #endif /* STM32L1XX_XD */
;;;219    
;;;220      /* Configure all GPIO port pins in Analog Input mode (floating input trigger OFF) */
;;;221      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
00000a  f64f70ff          MOV      r0,#0xffff
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;222    #if defined(STM32F30X)
;;;223      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
;;;224    #else
;;;225      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000012  2000              MOVS     r0,#0
000014  f88d0003          STRB     r0,[sp,#3]
;;;226    #endif
;;;227      //GPIO_Init(GPIOA, &GPIO_InitStructure); // Some GPIOA pins are used for JTAG and USB
;;;228      GPIO_Init(GPIOB, &GPIO_InitStructure);
000018  4669              MOV      r1,sp
00001a  4808              LDR      r0,|L2.60|
00001c  f7fffffe          BL       GPIO_Init
;;;229      GPIO_Init(GPIOC, &GPIO_InitStructure);
000020  4669              MOV      r1,sp
000022  4807              LDR      r0,|L2.64|
000024  f7fffffe          BL       GPIO_Init
;;;230      GPIO_Init(GPIOD, &GPIO_InitStructure);
000028  4669              MOV      r1,sp
00002a  4806              LDR      r0,|L2.68|
00002c  f7fffffe          BL       GPIO_Init
;;;231      GPIO_Init(GPIOE, &GPIO_InitStructure);
000030  4669              MOV      r1,sp
000032  4805              LDR      r0,|L2.72|
000034  f7fffffe          BL       GPIO_Init
;;;232    
;;;233    #if defined (USE_STM32L152_EVAL)
;;;234      GPIO_Init(GPIOH, &GPIO_InitStructure);
;;;235    #endif /* USE_STM32L152_EVAL */  
;;;236    
;;;237    #if defined (USE_STM32L152D_EVAL)
;;;238      GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;239      GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;240      GPIO_Init(GPIOH, &GPIO_InitStructure);
;;;241    #endif /* USE_STM32L152D_EVAL */ 
;;;242      
;;;243    #if defined (USE_STM3210E_EVAL)
;;;244      GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;245      GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;246    #endif /* USE_STM3210E_EVAL */
;;;247    
;;;248    }
000038  bd08              POP      {r3,pc}
;;;249    #endif /*STM32F37X*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      0x40010c00
                  |L2.64|
                          DCD      0x40011000
                  |L2.68|
                          DCD      0x40011400
                  |L2.72|
                          DCD      0x40011800

                          AREA ||i.Get_SerialNum||, CODE, READONLY, ALIGN=2

                  Get_SerialNum PROC
;;;489    *******************************************************************************/
;;;490    void Get_SerialNum(void)
000000  480a              LDR      r0,|L3.44|
;;;491    {
000002  b510              PUSH     {r4,lr}
;;;492      uint32_t Device_Serial0, Device_Serial1, Device_Serial2;
;;;493    
;;;494      Device_Serial0 = *(uint32_t*)ID1;
;;;495      Device_Serial1 = *(uint32_t*)ID2;
000004  6801              LDR      r1,[r0,#0]
000006  1d00              ADDS     r0,r0,#4
;;;496      Device_Serial2 = *(uint32_t*)ID3;
000008  6804              LDR      r4,[r0,#0]
00000a  1d00              ADDS     r0,r0,#4
00000c  6800              LDR      r0,[r0,#0]
;;;497      
;;;498      Device_Serial0 += Device_Serial2;
00000e  1808              ADDS     r0,r1,r0
000010  d00b              BEQ      |L3.42|
;;;499    
;;;500      if (Device_Serial0 != 0)
;;;501      {
;;;502        IntToUnicode (Device_Serial0, &Joystick_StringSerial[2] , 8);
000012  2208              MOVS     r2,#8
000014  4906              LDR      r1,|L3.48|
000016  f7fffffe          BL       IntToUnicode
;;;503        IntToUnicode (Device_Serial1, &Joystick_StringSerial[18], 4);
00001a  4905              LDR      r1,|L3.48|
00001c  4620              MOV      r0,r4
00001e  2204              MOVS     r2,#4
000020  e8bd4010          POP      {r4,lr}
000024  3110              ADDS     r1,r1,#0x10
000026  f7ffbffe          B.W      IntToUnicode
                  |L3.42|
;;;504      }
;;;505    }
00002a  bd10              POP      {r4,pc}
;;;506    
                          ENDP

                  |L3.44|
                          DCD      0x1ffff7e8
                  |L3.48|
                          DCD      Joystick_StringSerial+0x2

                          AREA ||i.IntToUnicode||, CODE, READONLY, ALIGN=2

                  IntToUnicode PROC
;;;513    *******************************************************************************/
;;;514    static void IntToUnicode (uint32_t value , uint8_t *pbuf , uint8_t len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;515    {
;;;516      uint8_t idx = 0;
000002  2300              MOVS     r3,#0
;;;517      
;;;518      for( idx = 0 ; idx < len ; idx ++)
;;;519      {
;;;520        if( ((value >> 28)) < 0xA )
000004  240a              MOVS     r4,#0xa
;;;521        {
;;;522          pbuf[ 2* idx] = (value >> 28) + '0';
000006  2530              MOVS     r5,#0x30
;;;523        }
;;;524        else
;;;525        {
;;;526          pbuf[2* idx] = (value >> 28) + 'A' - 10; 
000008  2637              MOVS     r6,#0x37
00000a  461f              MOV      r7,r3
00000c  e011              B        |L4.50|
00000e  bf00              NOP                            ;520
                  |L4.16|
000010  ebb47f10          CMP      r4,r0,LSR #28         ;520
000014  d902              BLS      |L4.28|
000016  eb057c10          ADD      r12,r5,r0,LSR #28     ;522
00001a  e001              B        |L4.32|
                  |L4.28|
00001c  eb067c10          ADD      r12,r6,r0,LSR #28
                  |L4.32|
000020  f801c013          STRB     r12,[r1,r3,LSL #1]
;;;527        }
;;;528        
;;;529        value = value << 4;
;;;530        
;;;531        pbuf[ 2* idx + 1] = 0;
000024  eb010c43          ADD      r12,r1,r3,LSL #1
000028  0100              LSLS     r0,r0,#4              ;529
00002a  1c5b              ADDS     r3,r3,#1
00002c  f88c7001          STRB     r7,[r12,#1]
000030  b2db              UXTB     r3,r3                 ;518
                  |L4.50|
000032  4293              CMP      r3,r2                 ;518
000034  d3ec              BCC      |L4.16|
;;;532      }
;;;533    }
000036  bdf0              POP      {r4-r7,pc}
;;;534    
                          ENDP


                          AREA ||i.JoyState||, CODE, READONLY, ALIGN=1

                  JoyState PROC
;;;392    *******************************************************************************/
;;;393    uint8_t JoyState(void)
000000  b510              PUSH     {r4,lr}
;;;394    {
;;;395       /* "right" key is pressed */
;;;396    #if !defined(USE_STM32373C_EVAL) && !defined(USE_STM32303C_EVAL)
;;;397       if (!STM_EVAL_PBGetState(Button_RIGHT))
000002  2003              MOVS     r0,#3
000004  f7fffffe          BL       STM_EVAL_PBGetState
000008  2800              CMP      r0,#0
;;;398    #else
;;;399         if (STM_EVAL_PBGetState(Button_RIGHT))
;;;400    #endif
;;;401         {
;;;402           return JOY_RIGHT;
;;;403         }
;;;404       /* "left" key is pressed */
;;;405    #if !defined(USE_STM32373C_EVAL) && !defined(USE_STM32303C_EVAL)
;;;406       if (!STM_EVAL_PBGetState(Button_LEFT))
00000a  f04f0004          MOV      r0,#4
00000e  d00b              BEQ      |L5.40|
000010  f7fffffe          BL       STM_EVAL_PBGetState
000014  b148              CBZ      r0,|L5.42|
;;;407    #else
;;;408         if (STM_EVAL_PBGetState(Button_LEFT))
;;;409    #endif
;;;410         {
;;;411           return JOY_LEFT;
;;;412         }
;;;413       /* "up" key is pressed */
;;;414    #if !defined(USE_STM32373C_EVAL) && !defined(USE_STM32303C_EVAL)
;;;415       if (!STM_EVAL_PBGetState(Button_UP))    
000016  2005              MOVS     r0,#5
000018  f7fffffe          BL       STM_EVAL_PBGetState
00001c  b138              CBZ      r0,|L5.46|
;;;416    #else
;;;417         if (STM_EVAL_PBGetState(Button_UP))    
;;;418    #endif
;;;419         {
;;;420           return JOY_UP;
;;;421         }
;;;422       /* "down" key is pressed */
;;;423    #if !defined(USE_STM32373C_EVAL) && !defined(USE_STM32303C_EVAL)
;;;424       if (!STM_EVAL_PBGetState(Button_DOWN))    
00001e  2006              MOVS     r0,#6
000020  f7fffffe          BL       STM_EVAL_PBGetState
000024  b128              CBZ      r0,|L5.50|
;;;425    #else
;;;426         if (STM_EVAL_PBGetState(Button_DOWN))
;;;427    #endif
;;;428         {
;;;429           return JOY_DOWN;
;;;430         }
;;;431       /* No key is pressed */
;;;432         else
;;;433         {
;;;434           return 0;
000026  2000              MOVS     r0,#0
                  |L5.40|
;;;435         } 
;;;436    }
000028  bd10              POP      {r4,pc}
                  |L5.42|
00002a  2003              MOVS     r0,#3                 ;411
00002c  bd10              POP      {r4,pc}
                  |L5.46|
00002e  2005              MOVS     r0,#5                 ;420
000030  bd10              POP      {r4,pc}
                  |L5.50|
000032  2002              MOVS     r0,#2                 ;429
000034  bd10              POP      {r4,pc}
;;;437    
                          ENDP


                          AREA ||i.Joystick_Send||, CODE, READONLY, ALIGN=2

                  Joystick_Send PROC
;;;444    *******************************************************************************/
;;;445    void Joystick_Send(uint8_t Keys)
000000  b538              PUSH     {r3-r5,lr}
;;;446    {
;;;447      uint8_t Mouse_Buffer[4] = {0, 0, 0, 0};
000002  2400              MOVS     r4,#0
;;;448      int8_t X = 0, Y = 0;
000004  4622              MOV      r2,r4
000006  4621              MOV      r1,r4
;;;449      
;;;450          switch (Keys)
000008  9400              STR      r4,[sp,#0]
00000a  2802              CMP      r0,#2
00000c  d00d              BEQ      |L6.42|
;;;451      {
;;;452        case JOY_LEFT:
;;;453          X -= CURSOR_STEP;
00000e  f06f0313          MVN      r3,#0x13
000012  2803              CMP      r0,#3                 ;450
000014  d005              BEQ      |L6.34|
000016  2804              CMP      r0,#4                 ;450
000018  d005              BEQ      |L6.38|
00001a  2805              CMP      r0,#5                 ;450
00001c  d114              BNE      |L6.72|
;;;454          break;
;;;455        case JOY_RIGHT:
;;;456    
;;;457          X += CURSOR_STEP;
;;;458          break;
;;;459        case JOY_UP:
;;;460          Y -= CURSOR_STEP;
00001e  4619              MOV      r1,r3
;;;461          break;
000020  e004              B        |L6.44|
                  |L6.34|
000022  461a              MOV      r2,r3                 ;453
000024  e002              B        |L6.44|
                  |L6.38|
000026  2214              MOVS     r2,#0x14              ;457
000028  e000              B        |L6.44|
                  |L6.42|
;;;462        case JOY_DOWN:
;;;463          Y += CURSOR_STEP;
00002a  2114              MOVS     r1,#0x14
                  |L6.44|
;;;464          break;
;;;465        default:
;;;466          return;
;;;467      }
;;;468      /* prepare buffer to send */
;;;469      Mouse_Buffer[1] = X;
;;;470      Mouse_Buffer[2] = Y;
;;;471      
;;;472      /* Reset the control token to inform upper layer that a transfer is ongoing */
;;;473      PrevXferComplete = 0;
00002c  4807              LDR      r0,|L6.76|
00002e  f88d2001          STRB     r2,[sp,#1]            ;469
000032  f88d1002          STRB     r1,[sp,#2]            ;470
000036  7004              STRB     r4,[r0,#0]
;;;474      
;;;475      /* Copy mouse position info in ENDP1 Tx Packet Memory Area*/
;;;476      USB_SIL_Write(EP1_IN, Mouse_Buffer, 4);
000038  2204              MOVS     r2,#4
00003a  4669              MOV      r1,sp
00003c  2081              MOVS     r0,#0x81
00003e  f7fffffe          BL       USB_SIL_Write
;;;477      
;;;478      /* Enable endpoint for transmission */
;;;479      SetEPTxValid(ENDP1);
000042  2001              MOVS     r0,#1
000044  f7fffffe          BL       SetEPTxValid
                  |L6.72|
;;;480    
;;;481    }
000048  bd38              POP      {r3-r5,pc}
;;;482    
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      PrevXferComplete

                          AREA ||i.Leave_LowPowerMode||, CODE, READONLY, ALIGN=2

                  Leave_LowPowerMode PROC
;;;275    *******************************************************************************/
;;;276    void Leave_LowPowerMode(void)
000000  4804              LDR      r0,|L7.20|
;;;277    {
;;;278      DEVICE_INFO *pInfo = &Device_Info;
;;;279      
;;;280      /* Set the device state to the correct state */
;;;281      if (pInfo->Current_Configuration != 0)
000002  7a81              LDRB     r1,[r0,#0xa]
;;;282      {
;;;283        /* Device configured */
;;;284        bDeviceState = CONFIGURED;
000004  4804              LDR      r0,|L7.24|
000006  b109              CBZ      r1,|L7.12|
000008  2105              MOVS     r1,#5
00000a  e000              B        |L7.14|
                  |L7.12|
;;;285      }
;;;286      else
;;;287      {
;;;288        bDeviceState = ATTACHED;
00000c  2101              MOVS     r1,#1
                  |L7.14|
00000e  6001              STR      r1,[r0,#0]  ; bDeviceState
;;;289      }
;;;290      
;;;291      /*Enable SystemCoreClock*/
;;;292      SystemInit();
000010  f7ffbffe          B.W      SystemInit
;;;293    }
;;;294    
                          ENDP

                  |L7.20|
                          DCD      Device_Info
                  |L7.24|
                          DCD      bDeviceState

                          AREA ||i.Set_System||, CODE, READONLY, ALIGN=2

                  Set_System PROC
;;;55     *******************************************************************************/
;;;56     void Set_System(void)
000000  b538              PUSH     {r3-r5,lr}
;;;57     {
;;;58     #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD)&& !defined(STM32L1XX_MD_PLUS)
;;;59       GPIO_InitTypeDef  GPIO_InitStructure;
;;;60     #endif /*STM32L1XX_XD */
;;;61     #if defined(USB_USE_EXTERNAL_PULLUP)
;;;62       GPIO_InitTypeDef  GPIO_InitStructure;
;;;63     #endif /* USB_USE_EXTERNAL_PULLUP */
;;;64       
;;;65       /*!< At this stage the microcontroller clock setting is already configured, 
;;;66            this is done through SystemInit() function which is called from startup
;;;67            file (startup_stm32xxx.s) before to branch to application main.
;;;68            To reconfigure the default setting of SystemInit() function, refer to
;;;69            system_stm32xxx.c file
;;;70          */ 
;;;71     
;;;72       /* Enable the PWR clock */
;;;73       RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
000002  2101              MOVS     r1,#1
000004  0708              LSLS     r0,r1,#28
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;74     
;;;75     #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)|| defined(STM32F37X)|| defined(STM32F30X)
;;;76       /* Enable the SYSCFG module clock (used for the USB disconnect feature) */
;;;77       RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
;;;78     #endif /* STM32L1XX_XD */   
;;;79     
;;;80       /* Set all the GPIOs to AIN *************************************************/
;;;81      #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS)&& !defined(STM32F37X) && !defined(STM32F30X)
;;;82       GPIO_AINConfig();
00000a  f7fffffe          BL       GPIO_AINConfig
;;;83     #endif /* STM32L1XX_XD */     
;;;84     
;;;85     #if  defined(STM32F37X) || defined(STM32F30X)
;;;86       
;;;87       /* Enable the USB disconnect GPIO clock */
;;;88       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;89     
;;;90      /*Set PA11,12 as IN - USB_DM,DP*/
;;;91       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA, ENABLE);
;;;92       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
;;;93       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;94       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;95       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;96       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;97       GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;98         
;;;99       /*SET PA11,12 for USB: USB_DM,DP*/
;;;100      GPIO_PinAFConfig(GPIOA, GPIO_PinSource11, GPIO_AF_14);
;;;101      GPIO_PinAFConfig(GPIOA, GPIO_PinSource12, GPIO_AF_14);
;;;102     
;;;103      /* USB_DISCONNECT used as USB pull-up */
;;;104      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;105      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;106      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;107      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;108      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;109      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
;;;110      
;;;111      /*Enable Joystick GPIOs clock*/
;;;112      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOF, ENABLE);
;;;113      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOB, ENABLE);
;;;114      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOE, ENABLE);
;;;115      /*Configure the JoyStick IOs as input floating*/
;;;116      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_4 | 
;;;117                                    GPIO_Pin_9 | GPIO_Pin_10;
;;;118      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;119      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN; /*PullDown is mandatory for Joystick pins*/
;;;120      GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;121    
;;;122      /*Configure the JoyStick IOs as input floating*/
;;;123      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_5;                  
;;;124      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
;;;125      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_DOWN; /*PullDown is mandatory for Joystick pins*/
;;;126      GPIO_Init(GPIOB, &GPIO_InitStructure); 
;;;127      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;  
;;;128      GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;129      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;  
;;;130      GPIO_Init(GPIOE, &GPIO_InitStructure);
;;;131    #endif /*STM32F37X && STM32F30X*/  
;;;132    #if !defined(STM32L1XX_MD) && !defined(STM32L1XX_HD) && !defined(STM32L1XX_MD_PLUS) && !defined(STM32F37X)&& !defined(STM32F30X)
;;;133         
;;;134      /* Enable the USB disconnect GPIO clock */
;;;135      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIO_DISCONNECT, ENABLE);
00000e  2101              MOVS     r1,#1
000010  2020              MOVS     r0,#0x20
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;136    
;;;137      /* USB_DISCONNECT used as USB pull-up */
;;;138      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
000016  f44f7400          MOV      r4,#0x200
00001a  f8ad4000          STRH     r4,[sp,#0]
;;;139      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001e  2003              MOVS     r0,#3
000020  f88d0002          STRB     r0,[sp,#2]
;;;140      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
000024  2014              MOVS     r0,#0x14
000026  f88d0003          STRB     r0,[sp,#3]
;;;141      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4813              LDR      r0,|L8.124|
00002e  f7fffffe          BL       GPIO_Init
;;;142    #endif /*STM32L1XX_MD*/
;;;143    
;;;144    #if defined(USB_USE_EXTERNAL_PULLUP)
;;;145      /* Enable the USB disconnect GPIO clock */
;;;146      RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIO_DISCONNECT, ENABLE);
;;;147    
;;;148      /* USB_DISCONNECT used as USB pull-up */
;;;149      GPIO_InitStructure.GPIO_Pin = USB_DISCONNECT_PIN;
;;;150      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
;;;151      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;152      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;153      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;154      GPIO_Init(USB_DISCONNECT, &GPIO_InitStructure);  
;;;155    #endif /* USB_USE_EXTERNAL_PULLUP */
;;;156    
;;;157      /* Joystick buttons configuration *******************************************/
;;;158      /* Configure the Joystick buttons in GPIO mode */
;;;159      STM_EVAL_PBInit(Button_RIGHT, Mode_GPIO);
000032  2100              MOVS     r1,#0
000034  2003              MOVS     r0,#3
000036  f7fffffe          BL       STM_EVAL_PBInit
;;;160      STM_EVAL_PBInit(Button_LEFT, Mode_GPIO);
00003a  2100              MOVS     r1,#0
00003c  2004              MOVS     r0,#4
00003e  f7fffffe          BL       STM_EVAL_PBInit
;;;161      STM_EVAL_PBInit(Button_UP, Mode_GPIO);
000042  2100              MOVS     r1,#0
000044  2005              MOVS     r0,#5
000046  f7fffffe          BL       STM_EVAL_PBInit
;;;162      STM_EVAL_PBInit(Button_DOWN, Mode_GPIO);
00004a  2100              MOVS     r1,#0
00004c  2006              MOVS     r0,#6
00004e  f7fffffe          BL       STM_EVAL_PBInit
;;;163    
;;;164      /* Configure the Key button in EXTI mode ************************************/
;;;165      STM_EVAL_PBInit(Button_KEY, Mode_EXTI);
000052  2101              MOVS     r1,#1
000054  2002              MOVS     r0,#2
000056  f7fffffe          BL       STM_EVAL_PBInit
;;;166    
;;;167      /* Configure the EXTI line 18 connected internally to the USB IP ************/
;;;168      EXTI_ClearITPendingBit(EXTI_Line18);
00005a  0265              LSLS     r5,r4,#9
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       EXTI_ClearITPendingBit
;;;169      EXTI_InitStructure.EXTI_Line = EXTI_Line18;
000062  4907              LDR      r1,|L8.128|
;;;170      EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
000064  2008              MOVS     r0,#8
000066  600d              STR      r5,[r1,#0]  ; EXTI_InitStructure
000068  7148              STRB     r0,[r1,#5]
;;;171      EXTI_InitStructure.EXTI_LineCmd = ENABLE;
00006a  2001              MOVS     r0,#1
00006c  7188              STRB     r0,[r1,#6]
;;;172      EXTI_Init(&EXTI_InitStructure);
00006e  4608              MOV      r0,r1
000070  f7fffffe          BL       EXTI_Init
;;;173    
;;;174      EXTI_ClearITPendingBit(KEY_BUTTON_EXTI_LINE);
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       EXTI_ClearITPendingBit
;;;175    }
00007a  bd38              POP      {r3-r5,pc}
;;;176    
                          ENDP

                  |L8.124|
                          DCD      0x40011400
                  |L8.128|
                          DCD      ||area_number.15||

                          AREA ||i.Set_USBClock||, CODE, READONLY, ALIGN=1

                  Set_USBClock PROC
;;;183    *******************************************************************************/
;;;184    void Set_USBClock(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;187      /* Enable USB clock */
;;;188      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
;;;189    
;;;190    #else
;;;191      /* Select USBCLK source */
;;;192      RCC_USBCLKConfig(RCC_USBCLKSource_PLLCLK_1Div5);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RCC_USBCLKConfig
;;;193      
;;;194      /* Enable the USB clock */
;;;195      RCC_APB1PeriphClockCmd(RCC_APB1Periph_USB, ENABLE);
000008  2101              MOVS     r1,#1
00000a  e8bd4010          POP      {r4,lr}
00000e  05c8              LSLS     r0,r1,#23
000010  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;196    #endif /* STM32L1XX_XD */
;;;197    
;;;198    }
;;;199    
                          ENDP


                          AREA ||i.USB_Cable_Config||, CODE, READONLY, ALIGN=2

                  USB_Cable_Config PROC
;;;362    *******************************************************************************/
;;;363    void USB_Cable_Config (FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;364    {
;;;365    #if defined(STM32L1XX_MD) || defined(STM32L1XX_HD)|| defined(STM32L1XX_MD_PLUS)
;;;366      if (NewState != DISABLE)
;;;367      {
;;;368        STM32L15_USB_CONNECT;
;;;369      }
;;;370      else
;;;371      {
;;;372        STM32L15_USB_DISCONNECT;
;;;373      }  
;;;374       
;;;375    #else
;;;376      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;377      {
;;;378        GPIO_ResetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000004  f44f7100          MOV      r1,#0x200
;;;379      }
;;;380      else
;;;381      {
;;;382        GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
000008  4610              MOV      r0,r2
00000a  d001              BEQ      |L10.16|
00000c  f7ffbffe          B.W      GPIO_ResetBits
                  |L10.16|
000010  f7ffbffe          B.W      GPIO_SetBits
;;;383      }
;;;384    #endif /* STM32L1XX_MD */
;;;385    }
;;;386    /*******************************************************************************
                          ENDP

                  |L10.20|
                          DCD      0x40011400

                          AREA ||i.USB_Interrupts_Config||, CODE, READONLY, ALIGN=1

                  USB_Interrupts_Config PROC
;;;301    *******************************************************************************/
;;;302    void USB_Interrupts_Config(void)
000000  b538              PUSH     {r3-r5,lr}
;;;303    {
;;;304      NVIC_InitTypeDef NVIC_InitStructure;
;;;305    
;;;306      /* 2 bit for pre-emption priority, 2 bits for subpriority */
;;;307      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;308     
;;;309    #if defined(STM32L1XX_MD)|| defined(STM32L1XX_HD) || defined(STM32L1XX_MD_PLUS)
;;;310      /* Enable the USB interrupt */
;;;311      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;312      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;313      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;314      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;315      NVIC_Init(&NVIC_InitStructure);
;;;316    
;;;317      /* Enable the USB Wake-up interrupt */
;;;318      NVIC_InitStructure.NVIC_IRQChannel = USB_FS_WKUP_IRQn;
;;;319      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;320      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;321      NVIC_Init(&NVIC_InitStructure);
;;;322    
;;;323    #elif defined(STM32F37X)
;;;324      /* Enable the USB interrupt */
;;;325      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQn;
;;;326      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
;;;327      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;328      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;329      NVIC_Init(&NVIC_InitStructure);
;;;330      
;;;331      /* Enable the USB Wake-up interrupt */
;;;332      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
;;;333      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;334      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;335      NVIC_Init(&NVIC_InitStructure);
;;;336      
;;;337    #else /* USE_STM3210B_EVAL or USE_STM3210E_EVAL */
;;;338      /* Enable the USB interrupt */
;;;339      NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;340      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
000010  2002              MOVS     r0,#2
000012  f88d0001          STRB     r0,[sp,#1]
;;;341      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2400              MOVS     r4,#0
000018  f88d4002          STRB     r4,[sp,#2]
;;;342      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  2501              MOVS     r5,#1
00001e  f88d5003          STRB     r5,[sp,#3]
;;;343      NVIC_Init(&NVIC_InitStructure);
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       NVIC_Init
;;;344      
;;;345      /* Enable the USB Wake-up interrupt */
;;;346      NVIC_InitStructure.NVIC_IRQChannel = USBWakeUp_IRQn;
000028  202a              MOVS     r0,#0x2a
00002a  f88d0000          STRB     r0,[sp,#0]
;;;347      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00002e  f88d5001          STRB     r5,[sp,#1]
;;;348      NVIC_Init(&NVIC_InitStructure);   
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       NVIC_Init
;;;349    #endif
;;;350      /* Enable the Key EXTI line Interrupt */
;;;351      NVIC_InitStructure.NVIC_IRQChannel = KEY_BUTTON_EXTI_IRQn;
000038  2017              MOVS     r0,#0x17
00003a  f88d0000          STRB     r0,[sp,#0]
;;;352      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00003e  f88d4001          STRB     r4,[sp,#1]
;;;353      NVIC_Init(&NVIC_InitStructure);
000042  4668              MOV      r0,sp
000044  f7fffffe          BL       NVIC_Init
;;;354    }
000048  bd38              POP      {r3-r5,pc}
;;;355    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  HSEStartUpStatus
000000  00                DCB      0x00

                          AREA ||area_number.15||, DATA, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.data||
                  EXTI_InitStructure
                          %        8

;*** Start embedded assembler ***

#line 1 "..\\src\\hw_config.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REV16|
#line 388 "..\\..\\..\\..\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_hw_config_c_25f922fc____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____REVSH|
#line 402
|__asm___11_hw_config_c_25f922fc____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___11_hw_config_c_25f922fc____RRX|
#line 587
|__asm___11_hw_config_c_25f922fc____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
